<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BINOKUB: DJ EDITION MOBILE v1.1</title>
    <style>
        /* --- ESTHÉTIQUE SPACE HARDGROOVE --- */
        body {
            background: radial-gradient(circle at center, #1a1a1a 0%, #000000 100%);
            color: white;
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh; /* Utiliser min-height pour éviter les coupures */
            margin: 0;
            padding: 10px; /* Un peu d'espace sur les bords */
            box-sizing: border-box; /* Important pour le responsive */
            touch-action: manipulation; /* Améliore la réactivité tactile */
            -webkit-tap-highlight-color: transparent; /* Enlève le flash gris sur mobile */
        }

        h1 {
            text-transform: uppercase;
            letter-spacing: 3px; /* Un peu moins d'espace pour mobile */
            text-shadow: 0 0 10px #00FFFF;
            margin-bottom: 15px;
            font-size: 20px; /* Taille adaptée mobile */
            text-align: center;
        }

        /* --- INTERFACE AUDIO RESPONSIVE --- */
        #audio-controls {
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap; /* PERMET AUX BOUTONS DE PASSER À LA LIGNE SUR MOBILE */
            justify-content: center; /* Centre les boutons */
            width: 100%;
        }

        .btn {
            background: transparent;
            border: 2px solid #00FFFF;
            color: #00FFFF;
            padding: 8px 12px; /* Boutons légèrement plus compacts */
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
            font-size: 12px; /* Texte plus petit sur mobile */
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
            flex-shrink: 0; /* Empêche les boutons de s'écraser */
        }

        .btn:hover, .btn:active {
            background: #00FFFF;
            color: black;
            box-shadow: 0 0 20px #00FFFF;
        }

        .btn-magenta { border-color: #D500F9; color: #D500F9; }
        .btn-magenta:hover, .btn-magenta:active { background: #D500F9; color: white; box-shadow: 0 0 20px #D500F9; }

        #file-input { display: none; }

        #track-name {
            font-size: 12px; color: #888; 
            max-width: 100%; /* Prend toute la largeur si nécessaire */
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            text-align: center;
            width: 100%; /* Force le nom de piste sur une nouvelle ligne sur petit écran */
            margin-top: 5px;
        }
        /* Sur écran plus large, on remet le nom de piste à côté */
        @media (min-width: 600px) {
             #track-name { width: auto; margin-top: 0; max-width: 200px; }
        }


        /* --- PLATEAU RESPONSIF (C'EST ICI QUE TOUT SE JOUE) --- */
        #game-board {
            display: grid;
            /* Au lieu de 60px fixes, on utilise des fractions égales */
            grid-template-columns: repeat(8, 1fr); 
            grid-template-rows: repeat(8, 1fr);
            
            /* Largeur dynamique : 95% de l'écran, mais maximum 480px */
            width: 95%; 
            max-width: 480px; 
            
            /* FORCE LE CARRÉ PARFAIT QUELLE QUE SOIT LA LARGEUR */
            aspect-ratio: 1 / 1; 

            border: 2px solid #333;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.15);
            position: relative;
            margin: 0 auto; /* Centrage horizontal */
        }

        .square {
            /* Plus de taille fixe ici, la grille gère tout */
            width: 100%; 
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .square.black { background-color: #050505; }
        .square.dark { background-color: #1a1a1a; border: 1px solid #2a2a2a; box-sizing: border-box; }

        .piece {
            /* Taille en POURCENTAGE de la case, pour s'adapter au mobile */
            width: 80%; 
            height: 80%;
            border-radius: 50%;
            transition: transform 0.2s ease-out; 
            position: relative;
            z-index: 2;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .piece.cyan { background-color: #00FFFF; box-shadow: 0 0 10px #00FFFF, inset 0 0 5px white; border: 2px solid #fff; }
        .piece.magenta { background-color: #D500F9; box-shadow: 0 0 10px #D500F9, inset 0 0 5px white; border: 2px solid #ff80ff; }

        /* Ajustement de la taille des bordures sur mobile */
        @media (max-width: 400px) {
            .piece.cyan, .piece.magenta { border-width: 1px; box-shadow: 0 0 5px var(--color); }
        }

        .king::after {
            content: ''; width: 30%; height: 30%; border-radius: 2px; /* Taille relative pour le roi */
            background-color: white; animation: pulse-king 1s infinite alternate;
        }
        @keyframes pulse-king { from { transform: scale(0.8); opacity: 0.8; } to { transform: scale(1.2); opacity: 1; } }

        .selected { transform: scale(1.2); z-index: 10; } /* Scale un peu moins fort sur mobile */
        .must-jump { box-shadow: 0 0 20px #FF0000 !important; }

        .particle {
            position: absolute; width: 4px; height: 4px; /* Particules plus petites */
            pointer-events: none; z-index: 20;
            animation: explode 0.8s ease-out forwards;
        }
        @keyframes explode { 0% { transform: translate(0, 0) scale(1); opacity: 1; } 100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; } }

        #status {
            margin-top: 15px; color: #888; font-size: 14px; font-weight: bold; letter-spacing: 1px; min-height: 20px; text-align: center;
        }
        .turn-cyan { color: #00FFFF !important; text-shadow: 0 0 10px #00FFFF; }
        .turn-magenta { color: #D500F9 !important; text-shadow: 0 0 10px #D500F9; }
        .combo-alert { color: #FF0000 !important; text-shadow: 0 0 15px red; animation: pulse 0.5s infinite; }

    </style>
</head>
<body>

    <h1>Binokub <span style="color:#D500F9">DJ SYSTEM</span></h1>
    
    <div id="audio-controls">
        <input type="file" id="file-input" accept="audio/*">
        <button class="btn" onclick="document.getElementById('file-input').click()">1. CHARGER TRACK</button>
        <button class="btn btn-magenta" id="play-btn" onclick="togglePlay()">STOP</button>
        <div id="track-name">AUCUNE PISTE</div>
    </div>

    <audio id="bg-music" loop></audio>

    <div id="game-board"></div>
    <div id="status" class="turn-cyan">TOUR DU JOUEUR: CYAN</div>

    <script>
        // --- LE CODE JAVASCRIPT EST EXACTEMENT LE MÊME QU'AVANT ---
        // SEUL LE CSS (VISUEL) A CHANGÉ POUR S'ADAPTER AU MOBILE.
        
        const boardElement = document.getElementById('game-board');
        const statusElement = document.getElementById('status');
        const audioPlayer = document.getElementById('bg-music');
        const fileInput = document.getElementById('file-input');
        const trackNameDisplay = document.getElementById('track-name');
        const playBtn = document.getElementById('play-btn');

        fileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const fileURL = URL.createObjectURL(file);
                audioPlayer.src = fileURL; audioPlayer.volume = 0.6;
                trackNameDisplay.innerText = file.name;
                audioPlayer.play(); playBtn.innerText = "PAUSE";
            }
        });

        function togglePlay() {
            if (audioPlayer.paused) { audioPlayer.play(); playBtn.innerText = "PAUSE"; } 
            else { audioPlayer.pause(); playBtn.innerText = "LECTURE"; }
        }

        let sfxCtx = null;
        function playSFX(type) {
            if (!sfxCtx) sfxCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (sfxCtx.state === 'suspended') sfxCtx.resume();
            const osc = sfxCtx.createOscillator(); const gain = sfxCtx.createGain();
            osc.connect(gain); gain.connect(sfxCtx.destination); const now = sfxCtx.currentTime;
            if (type === 'move') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(300, now + 0.1); 
                gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'capture') {
                osc.type = 'square'; osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(20, now + 0.4); 
                gain.gain.setValueAtTime(0.5, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4); osc.start(now); osc.stop(now + 0.4);
            } else if (type === 'king') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(200, now); osc.frequency.linearRampToValueAtTime(800, now + 0.5); 
                gain.gain.setValueAtTime(0.3, now); gain.gain.linearRampToValueAtTime(0, now + 0.5); osc.start(now); osc.stop(now + 0.5);
            }
        }

        let board = [
            [0, 2, 0, 2, 0, 2, 0, 2], [2, 0, 2, 0, 2, 0, 2, 0], [0, 2, 0, 2, 0, 2, 0, 2],
            [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0],
            [1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0]
        ];
        let selectedSquare = null; let turn = 1; let mustJumpFrom = null; let aiProcessing = false;

        function createBodyExplosion(r, c, color) {
            const index = r * 8 + c; if (!boardElement.children[index]) return;
            const square = boardElement.children[index]; const rect = square.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2; const centerY = rect.top + rect.height / 2;
            for (let i = 0; i < 20; i++) { // Moins de particules sur mobile pour la perf
                const p = document.createElement('div'); p.classList.add('particle'); p.style.backgroundColor = color;
                p.style.left = centerX + 'px'; p.style.top = centerY + 'px';
                const angle = Math.random() * Math.PI * 2; const dist = 20 + Math.random() * 40; // Distance réduite
                p.style.setProperty('--tx', Math.cos(angle) * dist + 'px');
                p.style.setProperty('--ty', Math.sin(angle) * dist + 'px');
                document.body.appendChild(p); setTimeout(() => p.remove(), 800);
            }
        }

        function drawBoard() {
            boardElement.innerHTML = '';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const square = document.createElement('div'); square.classList.add('square');
                    if ((r + c) % 2 === 0) square.classList.add('black');
                    else { square.classList.add('dark'); square.dataset.r = r; square.dataset.c = c; square.onclick = handleSquareClick; }
                    const val = board[r][c];
                    if (val !== 0) {
                        const piece = document.createElement('div'); piece.classList.add('piece');
                        if (val === 1 || val === 3) piece.classList.add('cyan'); else piece.classList.add('magenta');
                        if (val === 3 || val === 4) piece.classList.add('king');
                        if (selectedSquare && selectedSquare.r === r && selectedSquare.c === c) {
                            piece.classList.add('selected'); if (mustJumpFrom) piece.classList.add('must-jump');
                        }
                        square.appendChild(piece);
                    }
                    boardElement.appendChild(square);
                }
            }
        }

        function handleSquareClick(e) {
            if (turn === 2 || aiProcessing) return;
            let target = e.target;
            if (target.classList.contains('piece')) target = target.parentElement;
            if (!target.classList.contains('dark')) return;
            const r = parseInt(target.dataset.r); const c = parseInt(target.dataset.c);
            const clickedVal = board[r][c];
            let owner = (clickedVal === 1 || clickedVal === 3) ? 1 : (clickedVal === 2 || clickedVal === 4) ? 2 : 0;
            if (owner === 1) { 
                if (mustJumpFrom && (mustJumpFrom.r !== r || mustJumpFrom.c !== c)) return;
                selectedSquare = { r, c }; drawBoard();
            } else if (clickedVal === 0 && selectedSquare) { tryMove(selectedSquare.r, selectedSquare.c, r, c); }
        }

        function tryMove(fromR, fromC, toR, toC) {
            const res = getMoveValidity(fromR, fromC, toR, toC);
            if (res.valid) executeMove(fromR, fromC, toR, toC, res.jumped, res.midR, res.midC);
        }

        function getMoveValidity(fromR, fromC, toR, toC) {
            if (board[toR][toC] !== 0) return { valid: false };
            if (mustJumpFrom && (fromR !== mustJumpFrom.r || fromC !== mustJumpFrom.c)) return { valid: false };
            const dr = toR - fromR; const dc = toC - fromC;
            if (Math.abs(dr) !== Math.abs(dc)) return { valid: false };
            const val = board[fromR][fromC]; const isKing = (val === 3 || val === 4);
            const player = (val === 1 || val === 3) ? 1 : 2; const forward = (player === 1) ? -1 : 1;
            const dist = Math.abs(dr); const stepR = Math.sign(dr); const stepC = Math.sign(dc);

            if (!isKing) {
                if (dist === 1 && dr === forward && !mustJumpFrom) return { valid: true, jumped: false };
                if (dist === 2 && dr === forward * 2) {
                    const midR = fromR + stepR; const midC = fromC + stepC;
                    let midOwner = getOwner(board[midR][midC]);
                    if (midOwner !== 0 && midOwner !== player) return { valid: true, jumped: true, midR, midC };
                }
                return { valid: false };
            }
            if (isKing) {
                let obstacles = [];
                for (let i = 1; i < dist; i++) {
                    const cr = fromR + i*stepR; const cc = fromC + i*stepC;
                    if (board[cr][cc] !== 0) obstacles.push({r:cr, c:cc, val:board[cr][cc]});
                }
                if (obstacles.length === 0 && !mustJumpFrom) return { valid: true, jumped: false };
                if (obstacles.length === 1) {
                    const obs = obstacles[0];
                    let obsOwner = getOwner(obs.val);
                    if (obsOwner !== 0 && obsOwner !== player) return { valid: true, jumped: true, midR: obs.r, midC: obs.c };
                }
            }
            return { valid: false };
        }

        function getOwner(val) { return (val===1||val===3)?1:(val===2||val===4)?2:0; }

        function executeMove(fromR, fromC, toR, toC, jumped, midR, midC) {
            playSFX('move');
            const val = board[fromR][fromC];
            if (jumped) {
                playSFX('capture');
                const victimVal = board[midR][midC];
                createBodyExplosion(midR, midC, (victimVal === 1 || victimVal === 3) ? '#00FFFF' : '#D500F9');
                board[midR][midC] = 0; 
            }
            board[toR][toC] = val; board[fromR][fromC] = 0;
            let promoted = false;
            if (val === 1 && toR === 0) { board[toR][toC] = 3; promoted = true; playSFX('king'); }
            if (val === 2 && toR === 7) { board[toR][toC] = 4; promoted = true; playSFX('king'); }
            if (promoted) { endTurn(); return; }
            if (jumped && canCaptureAgain(toR, toC)) {
                mustJumpFrom = { r: toR, c: toC };
                if (turn === 1) { selectedSquare = { r: toR, c: toC }; statusElement.innerText = "ENCHAÎNEMENT REQUIS !"; statusElement.className = "combo-alert"; drawBoard(); }
                else { setTimeout(aiTurn, 500); drawBoard(); }
                return;
            }
            endTurn();
        }

        function canCaptureAgain(r, c) {
            const val = board[r][c]; const isKing = (val === 3 || val === 4); const player = getOwner(val);
            const dirs = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
            for (let dir of dirs) {
                const stepR = dir[0]; const stepC = dir[1];
                let dist = 1;
                while (true) {
                    const cr = r + dist*stepR; const cc = c + dist*stepC;
                    if (cr < 0 || cr > 7 || cc < 0 || cc > 7) break;
                    const cv = board[cr][cc];
                    if (cv === 0) { if (!isKing) break; dist++; continue; }
                    if (getOwner(cv) === player) break;
                    const lr = cr + stepR; const lc = cc + stepC;
                    if (lr >= 0 && lr <= 7 && lc >= 0 && lc <= 7 && board[lr][lc] === 0) {
                        if (isKing) return true;
                        if (!isKing && dist === 1) { const fwd = (player === 1) ? -1 : 1; if(stepR === fwd) return true; }
                    }
                    break;
                }
            }
            return false;
        }

        function endTurn() {
            selectedSquare = null; mustJumpFrom = null; turn = (turn === 1) ? 2 : 1; drawBoard();
            if (turn === 1) { statusElement.innerText = "TOUR : CYAN (VOUS)"; statusElement.className = "turn-cyan"; aiProcessing = false; }
            else { statusElement.innerText = "CORTEX CALCULE..."; statusElement.className = "turn-magenta"; aiProcessing = true; setTimeout(aiTurn, 800); }
        }

        function aiTurn() {
            let moves = []; let canJump = false;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const val = board[r][c];
                    if (getOwner(val) === 2) {
                        if (mustJumpFrom && (r !== mustJumpFrom.r || c !== mustJumpFrom.c)) continue;
                        for (let tr = 0; tr < 8; tr++) {
                            for (let tc = 0; tc < 8; tc++) {
                                if (board[tr][tc] === 0) {
                                    const res = getMoveValidity(r, c, tr, tc);
                                    if (res.valid) {
                                        if (res.jumped) { moves.push({fr:r, fc:c, tr:tr, tc:tc, jump:true, mr:res.midR, mc:res.midC}); canJump = true; }
                                        else if (!canJump) { moves.push({fr:r, fc:c, tr:tr, tc:tc, jump:false}); }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (moves.length === 0) { statusElement.innerText = "VICTOIRE ! CORTEX BLOQUÉ."; statusElement.style.color = "#00FF00"; return; }
            const jumps = moves.filter(m => m.jump);
            const finalMoves = jumps.length > 0 ? jumps : moves;
            const rm = finalMoves[Math.floor(Math.random() * finalMoves.length)];
            executeMove(rm.fr, rm.fc, rm.tr, rm.tc, rm.jump, rm.mr, rm.mc);
        }

        drawBoard();
    </script>
</body>
</html>
