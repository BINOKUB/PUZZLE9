<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BINOKUB: BASE MATCH</title>
    <style>
        :root {
            --bg-color: #121212;
            --tile-bg: #2a2a2a;
            --tile-selected: #d4af37;
            --tile-text: #e0e0e0;
            --accent-boom: #e74c3c;
            --accent-match: #27ae60;
            --accent-hint: #00d2d3;
            --accent-rescue: #9b59b6;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: var(--bg-color);
            color: var(--tile-text);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        /* En-tête avec bouton Règles */
        .header { display: flex; align-items: center; gap: 15px; margin-bottom: 10px; }
        h1 { margin: 0; letter-spacing: 2px; text-transform: uppercase; color: #d4af37; font-size: 1.8em; }
        .btn-rules { 
            width: 30px; height: 30px; border-radius: 50%; border: 2px solid #666; color: #666; 
            font-weight: bold; cursor: pointer; background: transparent; display: flex; 
            align-items: center; justify-content: center; font-size: 1.2em; transition: 0.2s;
        }
        .btn-rules:hover { border-color: #d4af37; color: #d4af37; }
        
        .hud { display: flex; gap: 20px; margin-bottom: 15px; font-size: 1.2em; font-weight: bold; }
        .hud span { color: #fff; }
        .hud .highlight { color: #d4af37; }

        #game-grid {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            gap: 5px;
            background: #000;
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #333;
            position: relative;
        }

        /* Overlay Universel */
        #message-overlay {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 30px;
            border: 2px solid #d4af37;
            text-align: center;
            display: none;
            z-index: 100;
            width: 85%;
            max-width: 400px;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }
        #message-overlay h2 { margin: 0 0 15px 0; font-size: 2em; text-transform: uppercase; }
        #message-overlay p { font-size: 1.1em; color: #ccc; margin-bottom: 20px; line-height: 1.4; }
        #message-overlay ul { text-align: left; color: #aaa; margin-bottom: 20px; font-size: 0.9em; padding-left: 20px; }
        #message-overlay li { margin-bottom: 5px; }
        
        .win-msg { color: #27ae60; }
        .lose-msg { color: #e74c3c; }
        .rescue-msg { color: var(--accent-rescue); }
        .info-msg { color: #d4af37; }

        .tile {
            width: 60px;
            height: 60px;
            background-color: var(--tile-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            transition: transform 0.1s, background-color 0.2s;
        }

        .tile:hover { background-color: #3a3a3a; }
        .tile.selected { background-color: var(--tile-selected); color: #000; transform: scale(1.1); box-shadow: 0 0 15px rgba(212, 175, 55, 0.5); z-index: 10; }
        .tile.empty { background: transparent; cursor: default; border: 1px dashed #333; }
        .tile.nine { color: #ff9f43; border: 1px solid #ff9f43; }

        /* Animations */
        @keyframes pop { 0% { transform: scale(1); } 50% { transform: scale(1.3); } 100% { transform: scale(0); opacity: 0;} }
        @keyframes fall { 0% { transform: translateY(-50px); opacity: 0; } 100% { transform: translateY(0); opacity: 1; } }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(0, 210, 211, 0.7); border-color: var(--accent-hint); } 70% { box-shadow: 0 0 0 10px rgba(0, 210, 211, 0); border-color: var(--accent-hint); } 100% { box-shadow: 0 0 0 0 rgba(0, 210, 211, 0); border-color: var(--accent-hint); } }
        @keyframes urgent { 0% { border-color: #d4af37; color:#d4af37; } 50% { border-color: #e74c3c; color: #e74c3c; box-shadow: 0 0 10px #e74c3c; } 100% { border-color: #d4af37; color:#d4af37; } }

        .anim-match { animation: pop 0.3s forwards; background-color: var(--accent-match) !important; }
        .anim-boom { animation: pop 0.4s forwards; background-color: var(--accent-boom) !important; }
        .anim-new { animation: fall 0.4s ease-out; }
        .anim-hint { animation: pulse 1.5s infinite; color: var(--accent-hint); font-weight: 900; z-index: 5; }
        .urgent-btn { animation: urgent 1s infinite; }

        .controls { margin-top: 20px; display: flex; gap: 10px; }
        button { padding: 10px 20px; background: transparent; border: 1px solid #d4af37; color: #d4af37; cursor: pointer; font-size: 16px; text-transform: uppercase; transition: 0.3s; font-weight: bold; }
        button:hover { background: #d4af37; color: #000; }
        button:disabled { border-color: #555; color: #555; cursor: not-allowed; background: transparent; animation: none !important; }
        
        #btn-hint { border-color: var(--accent-hint); color: var(--accent-hint); }
        #btn-hint:hover { background: var(--accent-hint); color: #000; }
        
        .btn-rescue { border-color: var(--accent-rescue) !important; color: var(--accent-rescue) !important; box-shadow: 0 0 10px rgba(155, 89, 182, 0.3); }
        .btn-rescue:hover { background: var(--accent-rescue) !important; color: #fff !important; box-shadow: 0 0 20px rgba(155, 89, 182, 0.8); }

    </style>
</head>
<body>

    <div class="header">
        <h1>Binokub: Base Match</h1>
        <button class="btn-rules" onclick="showRules()">?</button>
    </div>
    
    <div class="hud">
        <span>Réserve: <span id="reserve-count" class="highlight">40</span></span>
        <span>Score: <span id="score">0</span></span>
    </div>

    <div style="position:relative;">
        <div id="game-grid"></div>
        
        <div id="message-overlay">
            <h2 id="msg-title">TITRE</h2>
            <div id="msg-content"></div>
            <div id="overlay-buttons" style="margin-top:20px;"></div>
        </div>
    </div>

    <div class="controls">
        <button id="btn-hint" onclick="findAndShowHint()">Indice</button>
        <button id="btn-shuffle" onclick="shuffleGrid()">Brasser (<span id="shuffle-count">3</span>)</button>
        <button onclick="initGame()">Reset</button>
    </div>

    <script>
        const GRID_SIZE = 8;
        const INITIAL_RESERVE = 40;
        const RESCUE_AMOUNT = 24;
        
        const gridElement = document.getElementById('game-grid');
        const scoreElement = document.getElementById('score');
        const reserveElement = document.getElementById('reserve-count');
        const shuffleBtn = document.getElementById('btn-shuffle');
        const shuffleCountSpan = document.getElementById('shuffle-count');
        const msgOverlay = document.getElementById('message-overlay');
        const msgTitle = document.getElementById('msg-title');
        const msgContent = document.getElementById('msg-content');
        const overlayBtns = document.getElementById('overlay-buttons');

        let grid = []; 
        let selectedTile = null; 
        let score = 0;
        let reserve = 0;
        let shuffleLeft = 3;
        let isProcessing = false; 
        let hasUsedRescue = false;

        function initGame() {
            gridElement.innerHTML = '';
            grid = [];
            score = 0;
            reserve = INITIAL_RESERVE;
            shuffleLeft = 3;
            selectedTile = null;
            isProcessing = false;
            hasUsedRescue = false;
            
            scoreElement.innerText = score;
            reserveElement.innerText = reserve;
            shuffleCountSpan.innerText = shuffleLeft;
            shuffleBtn.disabled = false;
            shuffleBtn.classList.remove('urgent-btn');
            msgOverlay.style.display = 'none';

            for (let r = 0; r < GRID_SIZE; r++) {
                let row = [];
                for (let c = 0; c < GRID_SIZE; c++) {
                    let tile = document.createElement('div');
                    tile.className = 'tile';
                    tile.dataset.r = r;
                    tile.dataset.c = c;
                    tile.addEventListener('click', () => handleTileClick(r, c));
                    gridElement.appendChild(tile);
                    row.push({ val: 0, el: tile });
                }
                grid.push(row);
            }
            fillGrid(true, true); 
        }

        function fillGrid(isInitial = false, freeFill = false) {
            let cellsFilled = 0;
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    let cell = grid[r][c];
                    if (cell.val === 0) {
                        if (freeFill || reserve > 0) {
                            cell.val = Math.floor(Math.random() * 9) + 1;
                            if (!freeFill) {
                                reserve--;
                                reserveElement.innerText = reserve;
                            }
                            if(!isInitial) cell.el.classList.add('anim-new');
                            cellsFilled++;
                        }
                    }
                    updateVisual(cell);
                }
            }
            
            setTimeout(() => {
                document.querySelectorAll('.anim-new').forEach(e => e.classList.remove('anim-new'));
                checkGameState(); 
            }, 400);
        }

        function updateVisual(cell) {
            cell.el.innerText = (cell.val > 0) ? cell.val : '';
            cell.el.className = 'tile'; 
            if (cell.val === 9) cell.el.classList.add('nine');
            if (cell.val === 0) cell.el.classList.add('empty');
        }

        function handleTileClick(r, c) {
            document.querySelectorAll('.anim-hint').forEach(el => el.classList.remove('anim-hint'));
            if (isProcessing || grid[r][c].val === 0) return;

            if (!selectedTile) {
                selectedTile = { r, c };
                grid[r][c].el.classList.add('selected');
                return;
            }

            if (selectedTile.r === r && selectedTile.c === c) {
                grid[r][c].el.classList.remove('selected');
                selectedTile = null;
                return;
            }

            if (canConnect(selectedTile.r, selectedTile.c, r, c)) {
                attemptMatch(grid[selectedTile.r][selectedTile.c], grid[r][c]);
            } else {
                grid[selectedTile.r][selectedTile.c].el.classList.remove('selected');
                selectedTile = { r, c };
                grid[r][c].el.classList.add('selected');
            }
        }

        function canConnect(r1, c1, r2, c2) {
            if (r1 !== r2 && c1 !== c2) return false;
            if (r1 === r2) {
                let min = Math.min(c1, c2);
                let max = Math.max(c1, c2);
                for (let k = min + 1; k < max; k++) {
                    if (grid[r1][k].val !== 0) return false;
                }
            } else {
                let min = Math.min(r1, r2);
                let max = Math.max(r1, r2);
                for (let k = min + 1; k < max; k++) {
                    if (grid[k][c1].val !== 0) return false;
                }
            }
            return true;
        }

        function attemptMatch(cellA, cellB) {
            const sum = cellA.val + cellB.val;
            const isBomb = (cellA.val === 9 && cellB.val === 9);

            if (sum === 9 || isBomb) {
                isProcessing = true;
                cellA.el.classList.remove('selected');
                selectedTile = null;

                if (isBomb) {
                    triggerExplosion(cellA, cellB);
                } else {
                    cellA.el.classList.add('anim-match');
                    cellB.el.classList.add('anim-match');
                    cellA.val = 0; 
                    cellB.val = 0;
                    score += 100;
                    scoreElement.innerText = score;
                    setTimeout(applyGravity, 300);
                }
            } else {
                cellA.el.classList.remove('selected');
                selectedTile = { r: parseInt(cellB.el.dataset.r), c: parseInt(cellB.el.dataset.c) };
                cellB.el.classList.add('selected');
            }
        }

        function triggerExplosion(cellA, cellB) {
            let targets = [cellA, cellB];
            let rA = parseInt(cellA.el.dataset.r), cA = parseInt(cellA.el.dataset.c);
            let rB = parseInt(cellB.el.dataset.r), cB = parseInt(cellB.el.dataset.c);
            getNeighbors(rA, cA).forEach(n => targets.push(n));
            getNeighbors(rB, cB).forEach(n => targets.push(n));

            targets.forEach(t => {
                if(t.val !== 0) {
                    t.el.classList.add('anim-boom');
                    t.val = 0; 
                }
            });
            score += 500;
            scoreElement.innerText = score;
            setTimeout(applyGravity, 400);
        }

        function getNeighbors(r, c) {
            let neighbors = [];
            for(let i=-1; i<=1; i++) {
                for(let j=-1; j<=1; j++) {
                    if(i===0 && j===0) continue;
                    let nr = r+i, nc = c+j;
                    if(nr>=0 && nr<GRID_SIZE && nc>=0 && nc<GRID_SIZE) {
                        neighbors.push(grid[nr][nc]);
                    }
                }
            }
            return neighbors;
        }

        function applyGravity() {
            for (let c = 0; c < GRID_SIZE; c++) {
                let activeTiles = [];
                for (let r = 0; r < GRID_SIZE; r++) {
                    if (grid[r][c].val !== 0) activeTiles.push(grid[r][c].val);
                }
                while (activeTiles.length < GRID_SIZE) activeTiles.unshift(0); 
                for (let r = 0; r < GRID_SIZE; r++) {
                    grid[r][c].val = activeTiles[r];
                }
            }
            document.querySelectorAll('.anim-match, .anim-boom').forEach(e => {
                e.classList.remove('anim-match');
                e.classList.remove('anim-boom');
            });
            fillGrid(); 
            isProcessing = false;
        }

        function shuffleGrid() {
            if (shuffleLeft <= 0 || isProcessing) return;
            shuffleLeft--;
            shuffleCountSpan.innerText = shuffleLeft;
            if (shuffleLeft === 0) shuffleBtn.disabled = true;
            shuffleBtn.classList.remove('urgent-btn');

            let values = [];
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (grid[r][c].val !== 0) values.push(grid[r][c].val);
                }
            }

            for (let i = values.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [values[i], values[j]] = [values[j], values[i]];
            }
            
            for(let r=0; r<GRID_SIZE; r++) for(let c=0; c<GRID_SIZE; c++) grid[r][c].val = 0;

            let valIndex = 0;
            for(let r=GRID_SIZE-1; r>=0; r--) { 
                for(let c=0; c<GRID_SIZE; c++) { 
                    if(valIndex < values.length) {
                         grid[r][c].val = values[valIndex++];
                    }
                    updateVisual(grid[r][c]);
                }
            }
            
            checkGameState();
        }

        function checkGameState() {
            let isEmpty = true;
            let hasBlocks = false;
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (grid[r][c].val !== 0) { isEmpty = false; hasBlocks = true; break; }
                }
            }

            if (isEmpty && reserve === 0) {
                showOverlay("VICTOIRE !", "<p>Grille nettoyée.<br>Score: " + score + "</p>", "win-msg", false);
                return;
            }

            let canMove = false;
            if (hasBlocks) canMove = scanForAnyMove();

            if (!canMove && reserve === 0 && hasBlocks) {
                if (shuffleLeft > 0) {
                    shuffleBtn.classList.add('urgent-btn');
                    return;
                }
                if (!hasUsedRescue) {
                    showOverlay("IMPASSE", "<p>Plus de mouvements possibles.<br>Le QG propose un renfort d'urgence.</p>", "rescue-msg", true);
                } else {
                    showOverlay("GAME OVER", "<p>Aucun mouvement possible.<br>Score Final: " + score + "</p>", "lose-msg", false);
                }
            } else {
                 shuffleBtn.classList.remove('urgent-btn');
            }
        }

        function scanForAnyMove() {
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    let cell = grid[r][c];
                    if (cell.val === 0) continue;
                    for (let k = c + 1; k < GRID_SIZE; k++) {
                        let target = grid[r][k];
                        if (target.val === 0) continue; 
                        if (checkPair(cell, target)) return true;
                        break; 
                    }
                    for (let k = r + 1; k < GRID_SIZE; k++) {
                        let target = grid[k][c];
                        if (target.val === 0) continue;
                        if (checkPair(cell, target)) return true;
                        break;
                    }
                }
            }
            return false;
        }
        
        function checkPair(cellA, cellB) {
            let sum = cellA.val + cellB.val;
            let isBomb = (cellA.val === 9 && cellB.val === 9);
            return (sum === 9 || isBomb);
        }

        function triggerRescue() {
            msgOverlay.style.display = 'none';
            hasUsedRescue = true;
            shuffleGrid(); 
            reserve = RESCUE_AMOUNT; 
            reserveElement.innerText = reserve;
            fillGrid(false, false); 
        }

        function showOverlay(title, contentHTML, cssClass, isRescue) {
            msgTitle.innerText = title;
            msgTitle.className = cssClass;
            msgContent.innerHTML = contentHTML;
            overlayBtns.innerHTML = ''; 

            if (isRescue) {
                let btn = document.createElement('button');
                btn.innerText = "APPELER RENFORT (+24)";
                btn.className = "btn-rescue";
                btn.onclick = triggerRescue;
                overlayBtns.appendChild(btn);
                
                let btnGiveUp = document.createElement('button');
                btnGiveUp.innerText = "ABANDONNER";
                btnGiveUp.style.marginTop = "10px";
                btnGiveUp.style.fontSize = "0.8em";
                btnGiveUp.onclick = () => showOverlay("GAME OVER", "<p>Score Final: " + score + "</p>", "lose-msg", false);
                overlayBtns.appendChild(btnGiveUp);
            } else {
                let btn = document.createElement('button');
                btn.innerText = "NOUVELLE PARTIE";
                btn.onclick = initGame;
                overlayBtns.appendChild(btn);
                
                if(title !== "VICTOIRE !" && title !== "GAME OVER") {
                    // Pour le bouton règles, on ajoute un bouton fermer
                    let btnClose = document.createElement('button');
                    btnClose.innerText = "FERMER";
                    btnClose.style.marginTop = "10px";
                    btnClose.onclick = () => msgOverlay.style.display = 'none';
                    overlayBtns.appendChild(btnClose);
                }
            }
            msgOverlay.style.display = 'block';
        }
        
        function showRules() {
            let rulesHTML = `
                <ul>
                    <li><strong>BUT :</strong> Vider complètement la grille.</li>
                    <li><strong>MATCH :</strong> Associez deux chiffres dont la somme fait <strong>9</strong> (ex: 4+5, 2+7).</li>
                    <li><strong>BOMBE :</strong> Associez deux <strong>9</strong> pour tout faire exploser autour.</li>
                    <li><strong>VISÉE :</strong> Vous pouvez relier deux chiffres éloignés s'il n'y a <strong>que du vide</strong> entre eux (Ligne ou Colonne).</li>
                    <li><strong>SURVIE :</strong> Si vous êtes bloqué, utilisez "BRASSER" ou appelez le Renfort (une seule fois !).</li>
                </ul>
            `;
            showOverlay("RÈGLES DU JEU", rulesHTML, "info-msg", false);
        }

        function findAndShowHint() {
            if (isProcessing) return;
            document.querySelectorAll('.anim-hint').forEach(el => el.classList.remove('anim-hint'));

            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    let cell = grid[r][c];
                    if (cell.val === 0) continue;
                    for (let k = c + 1; k < GRID_SIZE; k++) {
                        let target = grid[r][k];
                        if (target.val === 0) continue; 
                        if (hintCheck(cell, target)) return; 
                        break; 
                    }
                    for (let k = r + 1; k < GRID_SIZE; k++) {
                        let target = grid[k][c];
                        if (target.val === 0) continue;
                        if (hintCheck(cell, target)) return;
                        break;
                    }
                }
            }
        }
        
        function hintCheck(cellA, cellB) {
            let sum = cellA.val + cellB.val;
            let isBomb = (cellA.val === 9 && cellB.val === 9);
            if (sum === 9 || isBomb) {
                cellA.el.classList.add('anim-hint');
                cellB.el.classList.add('anim-hint');
                return true; 
            }
            return false;
        }

        initGame();
    </script>
</body>
</html>